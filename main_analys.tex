\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    framesep=5pt
}

\lstset{style=mystyle}

\title{Документация к файлу main.c \\ Командный интерпретатор}
\author{Разработчик: [Ваше имя]}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Данный документ описывает структуру и функциональность главного модуля командного интерпретатора, реализованного в файле \texttt{main.c}. Модуль отвечает за основной цикл работы shell'а, обработку сигналов и взаимодействие с пользователем.
\end{abstract}

\tableofcontents

\section{Обзор модуля}
Файл \texttt{main.c} является центральным модулем командного интерпретатора, который реализует основной цикл \textbf{REPL} (Read-Eval-Print Loop). Модуль координирует работу всех компонентов системы: чтение ввода, парсинг команд и их выполнение.

\section{Структура модуля}

\subsection{Заголовочные файлы}
\begin{lstlisting}[language=C]
#include "shell.h"
\end{lstlisting}
Модуль подключает главный заголовочный файл, содержащий объявления всех структур данных и функций, используемых в проекте.

\subsection{Глобальные определения}
\begin{itemize}
    \item Макросы определены в \texttt{shell.h}
    \item Структуры данных: \texttt{command\_t}, \texttt{command\_sequence\_t}
\end{itemize}

\section{Функции модуля}

\subsection{Функция \texttt{check\_child}}
\begin{lstlisting}[language=C]
void check_child(int sig) {
    int status;
    pid_t pid;
    
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("[%d] Finished with status %d\n", pid, WEXITSTATUS(status));
    }
}
\end{lstlisting}

\textbf{Назначение}: Обработчик сигнала \texttt{SIGCHLD} для отслеживания завершения фоновых процессов.

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{sig} - номер сигнала (всегда \texttt{SIGCHLD})
\end{itemize}

\textbf{Особенности реализации}:
\begin{itemize}
    \item Использует \texttt{waitpid()} с флагом \texttt{WNOHANG} для неблокирующей проверки
    \item Обрабатывает все завершившиеся процессы в цикле
    \item Выводит информационное сообщение о завершении процесса
\end{itemize}

\subsection{Функция \texttt{print\_dir}}
\begin{lstlisting}[language=C]
char* print_dir() {
    long size = pathconf(".", _PC_PATH_MAX);
    if (size == -1) {
        size = 4096;
    }

    char *cwd = malloc((size_t)size);
    if (cwd == NULL) {
        perror("malloc");
        exit(2);
    }

    cwd = getcwd(cwd, (size_t)size);
    if (cwd == NULL) {
        perror("getcwd");
        free(cwd);
        exit(2);
    }

    return cwd;
}
\end{lstlisting}

\textbf{Назначение}: Получение текущей рабочей директории для отображения в приглашении.

\textbf{Возвращаемое значение}: Указатель на строку с текущим путем (требует освобождения).

\textbf{Особенности реализации}:
\begin{itemize}
    \item Динамически определяет максимальную длину пути
    \item Резервирует значение 4096 байт при ошибке определения
    \item Корректно обрабатывает ошибки выделения памяти
    \item Возвращает готовую для использования строку
\end{itemize}

\subsection{Функция \texttt{read\_line}}
\begin{lstlisting}[language=C]
char *read_line(void) {
    char *line = NULL;
    size_t linesize = 0;
    char* dir = print_dir();

    printf("%s> ", dir);
    fflush(stdout);
    free(dir);
    
    ssize_t num_chars_read = getline(&line, &linesize, stdin);
    
    if (num_chars_read <= 0) {
        free(line);
        return NULL;
    }
    
    if (line[num_chars_read - 1] == '\n') {
        line[num_chars_read - 1] = '\0';
    }
    
    return line;
}
\end{lstlisting}

\textbf{Назначение}: Чтение командной строки от пользователя.

\textbf{Возвращаемое значение}: Указатель на введенную строку или \texttt{NULL} при EOF.

\textbf{Особенности реализации}:
\begin{itemize}
    \item Использует \texttt{getline()} для безопасного чтения строк
    \item Автоматически выделяет достаточный объем памяти
    \item Удаляет символ новой строки из конца ввода
    \item Выводит приглашение с текущей директорией
\end{itemize}

\subsection{Функция \texttt{main}}
\begin{lstlisting}[language=C]
int main(void) {
    char *input;
    
    signal(SIGCHLD, check_child);
    
    printf("Shell R v7.2\n");
    printf("Type 'exit' to quit. Or use Ctrl + D\n");
    
    while ((input = read_line()) != NULL) {
        if (strlen(input) == 0) {
            free(input);
            continue;
        }
    
        // Парсим как единую команду с перенаправлениями
        command_t *cmd = parse_input(input);
        
        if (cmd != NULL) {
            // Для отладки - показываем что распарсилось print_command(cmd);
            
            // Выполняем команду
            execute_command(cmd);
            
            free_command(cmd);
        }        
    
        free(input);
    }
    
    printf("\nGoodbye!\n");
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Главная функция программы, реализующая основной цикл работы.

\textbf{Логика работы}:
\begin{enumerate}
    \item Установка обработчика сигналов для фоновых процессов
    \item Вывод приветственного сообщения
    \item Запуск основного цикла REPL:
    \begin{itemize}
        \item Чтение команды
        \item Пропуск пустых строк
        \item Парсинг ввода
        \item Выполнение команды
        \item Освобождение ресурсов
    \end{itemize}
    \item Корректное завершение программы
\end{enumerate}

\section{Взаимодействие с другими модулями}

\subsection{Зависимости}
\begin{itemize}
    \item \texttt{shell.h} - основные структуры и объявления
    \item \texttt{parcer.c} - функции парсинга команд
    \item \texttt{executor.c} - функции выполнения команд
    \item \texttt{cmdfrombash.c} - встроенные команды
\end{itemize}

\subsection{Поток данных}
\begin{enumerate}
    \item \texttt{read\_line()} → Ввод от пользователя
    \item \texttt{parse\_input()} → Разбор на структуру \texttt{command\_t}
    \item \texttt{execute\_command()} → Выполнение команды
    \item \texttt{free\_command()} → Освобождение памяти
\end{enumerate}

\section{Особенности реализации}

\subsection{Обработка сигналов}
\begin{itemize}
    \item Используется \texttt{signal(SIGCHLD, check\_child)} для отслеживания дочерних процессов
    \item Обеспечивает корректную работу фоновых процессов
\end{itemize}

\subsection{Управление памятью}
\begin{itemize}
    \item Все динамически выделенные ресурсы освобождаются
    \item Используется \texttt{getline()} для безопасного чтения строк
    \item Проверка ошибок выделения памяти
\end{itemize}

\subsection{Обработка ошибок}
\begin{itemize}
    \item Проверка возвращаемых значений системных вызовов
    \item Корректная обработка конца файла (Ctrl+D)
    \item Освобождение памяти при ошибках
\end{itemize}

\section{Примеры использования}

\subsection{Нормальный workflow}
\begin{verbatim}
/home/user> ls -la
[вывод команды ls]
/home/user> exit
Goodbye!
\end{verbatim}

\subsection{Фоновые процессы}
\begin{verbatim}
/home/user> sleep 10 &
[1234] Started in fonius
/home/user> [1234] Finished with status 0
\end{verbatim}

\section{Заключение}
Модуль \texttt{main.c} успешно реализует основной цикл командного интерпретатора, обеспечивая стабильную работу, корректное управление ресурсами и удобное взаимодействие с пользователем. Архитектура модуля позволяет легко расширять функциональность shell'а.

\end{document}