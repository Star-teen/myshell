\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    framesep=5pt
}

\lstset{style=mystyle}

\title{Документация к файлу cmdfrombash.c \\ Встроенные команды shell'а}
\author{Разработчик: [Ваше имя]}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Данный документ описывает структуру и функциональность модуля встроенных команд, реализованного в файле \texttt{cmdfrombash.c}. Модуль содержит реализации команд, которые выполняются непосредственно в процессе shell'а без создания дочерних процессов, включая управление директориями, переменными окружения и завершение работы.
\end{abstract}

\tableofcontents

\section{Обзор модуля}
Файл \texttt{cmdfrombash.c} реализует встроенные команды shell'а, которые обеспечивают:
\begin{itemize}
    \item Управление текущей рабочей директорией
    \item Завершение работы shell'а
    \item Управление переменной окружения PATH
    \item Просмотр и модификация системных настроек
    \item Базовые операции с окружением выполнения
\end{itemize}

\section{Структура модуля}

\subsection{Заголовочные файлы}
\begin{lstlisting}[language=C]
#include "shell.h"
\end{lstlisting}

Модуль использует только главный заголовочный файл, так как все необходимые системные вызовы уже объявлены в \texttt{shell.h}.

\section{Функции встроенных команд}

\subsection{Функция \texttt{from\_bash\_cd}}
\begin{lstlisting}[language=C]
int from_bash_cd(char **args) {
    if (args[1] == NULL) {
        return 1;
    }

    if (args[2] != NULL) {
        perror("cd: too many arguments\n");
        return 1;
    }

    if (chdir(args[1]) != 0) {
        perror("cd");
        return 1;
    }
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Смена текущей рабочей директории.

\textbf{Синтаксис}: \texttt{cd <директория>}

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{args[1]} - целевая директория
\end{itemize}

\textbf{Логика работы}:
\begin{enumerate}
    \item Проверка наличия аргумента (директории)
    \item Проверка на избыточное количество аргументов
    \item Вызов системной функции \texttt{chdir()}
    \item Обработка ошибок изменения директории
\end{enumerate}

\textbf{Возвращаемые значения}:
\begin{itemize}
    \item 0 - успешное изменение директории
    \item 1 - ошибка (нет аргумента, слишком много аргументов, несуществующая директория)
\end{itemize}

\textbf{Особенности}:
\begin{itemize}
    \item Команда изменяет текущую рабочую директорию всего процесса shell'а
    \item Все последующие команды выполняются в новой директории
    \item Поддерживает как абсолютные, так и относительные пути
\end{itemize}

\subsection{Функция \texttt{from\_bash\_exit}}
\begin{lstlisting}[language=C]
int from_bash_exit(char **args) {
    int exit_code = 0;

    if (args[1] != NULL) {
        exit_code = atoi(args[1]);
    }
    
    exit(exit_code);
}
\end{lstlisting}

\textbf{Назначение}: Завершение работы shell'а.

\textbf{Синтаксис}: \texttt{exit [код\_завершения]}

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{args[1]} - необязательный код завершения (по умолчанию 0)
\end{itemize}

\textbf{Логика работы}:
\begin{enumerate}
    \item Проверка наличия аргумента с кодом завершения
    \item Преобразование строки в число с помощью \texttt{atoi()}
    \item Вызов системной функции \texttt{exit()} с соответствующим кодом
\end{enumerate}

\textbf{Особенности}:
\begin{itemize}
    \item Команда немедленно завершает работу всего shell'а
    \item Поддерживает пользовательские коды завершения
    \item По умолчанию возвращает код 0 (успешное завершение)
\end{itemize}

\subsection{Функция \texttt{from\_path}}
\begin{lstlisting}[language=C]
int from_path(char **args) {
    char *path = getenv("PATH");
    if (path == NULL) {
        printf("PATH is not set\n");
    } else {
        printf("PATH=%s\n", path);
    }
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Вывод текущего значения переменной окружения PATH.

\textbf{Синтаксис}: \texttt{path}

\textbf{Логика работы}:
\begin{enumerate}
    \item Получение значения переменной PATH с помощью \texttt{getenv()}
    \item Проверка на NULL (переменная не установлена)
    \item Вывод значения в формате \texttt{PATH=<значение>}
\end{enumerate}

\textbf{Возвращаемые значения}:
\begin{itemize}
    \item 0 - всегда успешное выполнение
\end{itemize}

\textbf{Особенности}:
\begin{itemize}
    \item Не изменяет переменную PATH, только отображает её значение
    \item Показывает все директории, в которых shell ищет исполняемые файлы
\end{itemize}

\subsection{Функция \texttt{set\_path}}
\begin{lstlisting}[language=C]
int set_path(char **args) {
    if (args[1] == NULL) {
        fprintf(stderr, "setpath: missing argument\n");
        fprintf(stderr, "Usage: setpath <new_path>\n");
        return 1;
    }

    if (args[2] != NULL) {
        fprintf(stderr, "setpath: too many arguments\n");
        fprintf(stderr, "Usage: setpath <new_path>\n");
        return 1;
    }

    if (setenv("PATH", args[1], 1) != 0) {
        perror("setpath");
        return 1;
    }
    
    printf("PATH set to: %s\n", args[1]);
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Установка нового значения переменной окружения PATH.

\textbf{Синтаксис}: \texttt{setpath <новый\_путь>}

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{args[1]} - новое значение переменной PATH
\end{itemize}

\textbf{Логика работы}:
\begin{enumerate}
    \item Проверка наличия обязательного аргумента
    \item Проверка на избыточное количество аргументов
    \item Установка переменной PATH с помощью \texttt{setenv()}
    \item Вывод подтверждающего сообщения
\end{enumerate}

\textbf{Возвращаемые значения}:
\begin{itemize}
    \item 0 - успешная установка PATH
    \item 1 - ошибка (нет аргумента, слишком много аргументов, ошибка setenv)
\end{itemize}

\textbf{Особенности}:
\begin{itemize}
    \item Полностью заменяет текущее значение PATH
    \item Использует \texttt{setenv()} с флагом перезаписи (1)
    \item Выводит понятные сообщения об ошибках с usage information
\end{itemize}

\subsection{Функция \texttt{add\_to\_path}}
\begin{lstlisting}[language=C]
int add_to_path(char **args) {
    if (args[1] == NULL) {
        fprintf(stderr, "addpath: missing directory\n");
        fprintf(stderr, "Usage: addpath <directory>\n");
        return 1;
    }

    char *current_path = getenv("PATH");
    if (current_path == NULL) {
        // Если PATH не установлен, создаем новый
        if (setenv("PATH", args[1], 1) != 0) {
            perror("addpath");
            return 1;
        }
    } else {
        // Добавляем новую директорию в начало PATH
        size_t new_len = strlen(current_path) + strlen(args[1]) + 2;
        char *new_path = malloc(new_len);
        if (new_path == NULL) {
            perror("addpath: malloc");
            return 1;
        }
        
        snprintf(new_path, new_len, "%s:%s", args[1], current_path);
        
        if (setenv("PATH", new_path, 1) != 0) {
            perror("addpath");
            free(new_path);
            return 1;
        }
        
        free(new_path);
    }
    
    printf("Added '%s' to PATH\n", args[1]);
    printf("New PATH: %s\n", getenv("PATH"));
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Добавление директории в начало переменной PATH.

\textbf{Синтаксис}: \texttt{addpath <директория>}

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{args[1]} - директория для добавления
\end{itemize}

\textbf{Логика работы}:
\begin{enumerate}
    \item Проверка наличия обязательного аргумента
    \item Получение текущего значения PATH
    \item Если PATH не установлен - создание нового
    \item Если PATH установлен - добавление директории в начало
    \item Формирование новой строки PATH с разделителем ":"
    \item Установка обновленного значения PATH
\end{enumerate}

\textbf{Возвращаемые значения}:
\begin{itemize}
    \item 0 - успешное добавление в PATH
    \item 1 - ошибка (нет аргумента, ошибка malloc, ошибка setenv)
\end{itemize}

\textbf{Особенности}:
\begin{itemize}
    \item Добавляет директорию в \textbf{начало} PATH (высший приоритет)
    \item Корректно обрабатывает случай когда PATH не установлен
    \item Динамически выделяет память для новой строки PATH
    \item Выводит старое и новое значение PATH для подтверждения
\end{itemize}

\subsection{Функция \texttt{reset\_path}}
\begin{lstlisting}[language=C]
int reset_path(char **args) {
    const char *default_path = "/home/ruslan/.vscode-server/bin/ac4cbdf48759c7d8c3eb91ffe6bb04316e263c57/bin/remote-cli:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/mnt/c/Program Files (x86)/Common Files/Oracle/Java/javapath:/mnt/c/Windows/System32:/mnt/c/Windows:/mnt/c/Windows/System32/wbem:/mnt/c/Windows/System32/WindowsPowerShell/v1.0:/mnt/c/Windows/System32/OpenSSH:/mnt/c/Program Files (x86)/NVIDIA Corporation/PhysX/Common:/mnt/c/Code Write/FreePascal/bin/i386-Win32:/mnt/c/ProgramData/chocolatey/bin:/mnt/c/Program Files/Git/cmd:/mnt/c/Users/123/Desktop/MASM/bin:/mnt/c/msys64/ucrt64/bin:/mnt/c/Users/123/AppData/Local/Microsoft/WindowsApps:/mnt/c/Users/123/AppData/Local/Programs/Microsoft VS Code/bin:/mnt/c/Users/123/AppData/Local/Programs/Python/Python311:/snap/bin";
    
    if (setenv("PATH", default_path, 1) != 0) {
        perror("resetpath");
        return 1;
    }
    
    printf("PATH reset to default: %s\n", default_path);
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Сброс переменной PATH к значению по умолчанию.

\textbf{Синтаксис}: \texttt{resetpath}

\textbf{Логика работы}:
\begin{enumerate}
    \item Использование предопределенного значения PATH по умолчанию
    \item Установка переменной PATH с помощью \texttt{setenv()}
    \item Вывод подтверждающего сообщения
\end{enumerate}

\textbf{Возвращаемые значения}:
\begin{itemize}
    \item 0 - успешный сброс PATH
    \item 1 - ошибка установки переменной
\end{itemize}

\textbf{Особенности}:
\begin{itemize}
    \item Восстанавливает PATH к жестко заданному значению по умолчанию
    \item Значение по умолчанию включает системные директории и пути WSL
    \item Полезно для восстановления работоспособности после некорректных изменений PATH
\end{itemize}

\section{Главная функция диспетчеризации}

\subsection{Функция \texttt{execute\_bash\_cmd}}
\begin{lstlisting}[language=C]
int execute_bash_cmd(char **args) {
    if (args[0] == NULL) {
        return 1;
    }

    if (strcmp(args[0], "cd") == 0) {
        return from_bash_cd(args);
    } else if (strcmp(args[0], "exit") == 0) {
        return from_bash_exit(args);
    } else if (strcmp(args[0], "path") == 0) {
        return from_path(args);
    } else if (strcmp(args[0], "setpath") == 0) {
        return set_path(args);
    } else if (strcmp(args[0], "addpath") == 0) {
        return add_to_path(args);
    } else if (strcmp(args[0], "resetpath") == 0) {
        return reset_path(args);
    }

    return -1; // Не встроенная команда
}
\end{lstlisting}

\textbf{Назначение}: Определение и вызов соответствующей встроенной команды.

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{args} - массив строк с командой и аргументами
\end{itemize}

\textbf{Логика работы}:
\begin{enumerate}
    \item Проверка на пустую команду
    \item Последовательное сравнение \texttt{args[0]} с именами встроенных команд
    \item Вызов соответствующей функции-обработчика
    \item Возврат -1 если команда не является встроенной
\end{enumerate}

\textbf{Возвращаемые значения}:
\begin{itemize}
    \item 0/1 - результат выполнения встроенной команды
    \item -1 - команда не является встроенной
\end{itemize}

\textbf{Поддерживаемые команды}:
\begin{itemize}
    \item \texttt{cd} - смена директории
    \item \texttt{exit} - завершение shell'а
    \item \texttt{path} - просмотр PATH
    \item \texttt{setpath} - установка PATH
    \item \texttt{addpath} - добавление в PATH
    \item \texttt{resetpath} - сброс PATH
\end{itemize}

\section{Примеры использования}

\subsection{Пример 1: Работа с директориями}
\begin{verbatim}
$ pwd
/home/user
$ cd /var/log
$ pwd
/var/log
$ cd /nonexistent
cd: No such file or directory
\end{verbatim}

\subsection{Пример 2: Управление PATH}
\begin{verbatim}
$ path
PATH=/usr/local/bin:/usr/bin:/bin
$ setpath /custom/bin:/other/bin
PATH set to: /custom/bin:/other/bin
$ addpath /new/bin
Added '/new/bin' to PATH
New PATH: /new/bin:/custom/bin:/other/bin
$ resetpath
PATH reset to default: [длинная строка с путями по умолчанию]
\end{verbatim}

\subsection{Пример 3: Завершение работы}
\begin{verbatim}
$ exit
Goodbye!
$ exit 1
# Завершение с кодом 1
\end{verbatim}

\section{Особенности реализации}

\subsection{Обработка аргументов}
\begin{itemize}
    \item Все функции проверяют наличие обязательных аргументов
    \item Проверка на избыточное количество аргументов
    \item Вывод понятных сообщений об ошибках с usage information
\end{itemize}

\subsection{Управление памятью}
\begin{itemize}
    \item Функция \texttt{add\_to\_path} динамически выделяет память для новой строки PATH
    \item Корректное освобождение памяти при ошибках
    \item Использование безопасных функций работы со строками (\texttt{snprintf})
\end{itemize}

\subsection{Обработка ошибок}
\begin{itemize}
    \item Проверка возвращаемых значений системных вызовов
    \item Использование \texttt{perror()} для системных ошибок
    \item Возврат соответствующих кодов ошибок
\end{itemize}

\subsection{Безопасность}
\begin{itemize}
    \item Проверка границ строк при работе с путями
    \item Использование \texttt{snprintf} вместо \texttt{sprintf}
    \item Валидация входных аргументов
\end{itemize}

\section{Взаимодействие с другими модулями}

\subsection{Зависимости}
\begin{itemize}
    \item \texttt{shell.h} - объявления структур и констант
    \item \texttt{executor.c} - вызов \texttt{execute\_bash\_cmd()} для определения типа команды
\end{itemize}

\subsection{Поток данных}
\begin{enumerate}
    \item \texttt{executor.c} → Вызов \texttt{execute\_bash\_cmd()} с разобранными аргументами
    \item \texttt{execute\_bash\_cmd()} → Определение и вызов соответствующей встроенной команды
    \item Функция-обработчик → Выполнение команды и возврат статуса
    \item Возврат статуса выполнения в \texttt{executor.c}
\end{enumerate}

\section{Расширяемость}

Система встроенных команд легко расширяема. Для добавления новой команды необходимо:

\begin{enumerate}
    \item Реализовать функцию-обработчик с сигнатурой \texttt{int function\_name(char **args)}
    \item Добавить проверку в функцию \texttt{execute\_bash\_cmd()}
    \item Объявить функцию в \texttt{shell.h}
\end{enumerate}

\section{Заключение}
Модуль \texttt{cmdfrombash.c} реализует основные встроенные команды shell'а, которые обеспечивают:

\begin{itemize}
    \item Управление файловой системой (команда \texttt{cd})
    \item Контроль работы shell'а (команда \texttt{exit})
    \item Гибкое управление переменными окружения (команды \texttt{path}, \texttt{setpath}, \texttt{addpath}, \texttt{resetpath})
    \item Понятные сообщения об ошибках и usage information
    \item Надежную обработку граничных случаев и ошибок
\end{itemize}

Встроенные команды выполняются эффективно без создания дочерних процессов, что делает их быстрыми и позволяющими напрямую влиять на состояние shell'а. Модуль успешно интегрируется с системой выполнения команд и обеспечивает базовую функциональность управления shell'ом.

\end{document}