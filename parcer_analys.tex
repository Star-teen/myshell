\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    framesep=5pt
}

\lstset{style=mystyle}

\title{Документация к файлу parcer.c \\ Парсер командной строки}
\author{Разработчик: [Ваше имя]}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Данный документ описывает структуру и функциональность модуля парсинга командной строки, реализованного в файле \texttt{parcer.c}. Модуль отвечает за преобразование текстового ввода пользователя в структурированные команды с учетом специальных символов, кавычек, экранирования и перенаправлений.
\end{abstract}

\tableofcontents

\section{Обзор модуля}
Файл \texttt{parcer.c} реализует сложный лексический анализатор командной строки, который обрабатывает:
\begin{itemize}
    \item Разделение на токены с учетом пробельных символов
    \item Обработку двойных кавычек и экранирования
    \item Распознавание специальных символов и операторов
    \item Обработку перенаправлений ввода/вывода
    \item Парсинг конвейеров и последовательностей команд
    \item Выделение фонового режима выполнения
\end{itemize}

\section{Структура модуля}

\subsection{Заголовочные файлы}
\begin{lstlisting}[language=C]
#include "shell.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
\end{lstlisting}

\subsection{Глобальные константы и переменные}
\begin{lstlisting}[language=C]
static const char DELIMITERS[] = " \t\n\r";
\end{lstlisting}

\subsection{Прототипы внутренних функций}
\begin{lstlisting}[language=C]
void process_redirections_and_pipes(command_t *cmd, char **words, int *word_num);
\end{lstlisting}

\section{Вспомогательные функции}

\subsection{Функция \texttt{is\_special\_char}}
\begin{lstlisting}[language=C]
int is_special_char(char c) {
    const char *special_chars = "@#%!&$^;:,(){}[]";
    return (strchr(special_chars, c) != NULL);
}
\end{lstlisting}

\textbf{Назначение}: Проверка, является ли символ специальным.

\textbf{Параметры}:
\begin{itemize}
    \item \texttt{c} - проверяемый символ
\end{itemize}

\textbf{Возвращаемое значение}: 1 если символ специальный, 0 в противном случае.

\subsection{Функция \texttt{is\_redirection\_char}}
\begin{lstlisting}[language=C]
int is_redirection_char(char *str) {
    return (strcmp(str, ">") == 0 || strcmp(str, ">>") == 0 || 
            strcmp(str, "<") == 0 || strcmp(str, "2>") == 0 || 
            strcmp(str, "2>>") == 0 || strcmp(str, "2>&1") == 0);
}
\end{lstlisting}

\textbf{Назначение}: Проверка, является ли строка оператором перенаправления.

\subsection{Функция \texttt{is\_command\_separator}}
\begin{lstlisting}[language=C]
int is_command_separator(const char *str) {
    return (strcmp(str, ";") == 0 || strcmp(str, "&&") == 0 || strcmp(str, "||") == 0);
}
\end{lstlisting}

\textbf{Назначение}: Проверка, является ли строка разделителем команд.

\subsection{Функция \texttt{get\_separator\_type}}
\begin{lstlisting}[language=C]
int get_separator_type(const char *sep) {
    if (strcmp(sep, ";") == 0) return 0;
    if (strcmp(sep, "&&") == 0) return 1;
    if (strcmp(sep, "||") == 0) return 2;
    return -1;
}
\end{lstlisting}

\textbf{Назначение}: Получение числового типа разделителя.

\textbf{Коды возврата}:
\begin{itemize}
    \item 0 - точка с запятой (;)
    \item 1 - логическое И (\&\&)
    \item 2 - логическое ИЛИ (||)
    \item -1 - неизвестный разделитель
\end{itemize}

\section{Основные функции парсинга}

\subsection{Функция \texttt{parse\_input}}
\begin{lstlisting}[language=C]
command_t *parse_input(const char *input) {
    if (input == NULL || strlen(input) == 0) {
        return NULL;
    }

    command_t *cmd = malloc(sizeof(command_t));
    if (cmd == NULL) {
        perror("malloc");
        return NULL;
    }

    // Инициализация структуры с новыми полями
    cmd->words = NULL;
    cmd->word_num = 0;
    cmd->fonius = 0;
    cmd->input_file = NULL;
    cmd->output_file = NULL;
    cmd->error_file = NULL;    
    cmd->append_output = 0;
    cmd->append_error = 0;     
    cmd->merge_output = 0;     
    cmd->pipeline = NULL;
    cmd->pipeline_count = 0;

    char *line = strdup(input);
    if (line == NULL) {
        perror("strdup");
        free(cmd);
        return NULL;
    }
    // ... продолжение парсинга
}
\end{lstlisting}

\textbf{Назначение}: Основная функция парсинга входной строки в структуру команды.

\textbf{Алгоритм работы}:
\begin{enumerate}
    \item Проверка входных данных и выделение памяти
    \item Инициализация структуры \texttt{command\_t}
    \item Копирование входной строки для обработки
    \item Посимвольный анализ с учетом:
    \begin{itemize}
        \item Экранирования обратным слешем
        \item Двойных кавычек
        \item Специальных символов и операторов
    \end{itemize}
    \item Обработка фонового режима
    \item Обработка перенаправлений и конвейеров
    \item Формирование итогового массива слов
\end{enumerate}

\textbf{Особенности обработки токенов}:
\begin{itemize}
    \item \textbf{Двойные символы}: \texttt{>>}, \texttt{<<}, \texttt{\&\&}, \texttt{||} обрабатываются как единые токены
    \item \textbf{Перенаправления stderr}: \texttt{2>}, \texttt{2>>}, \texttt{2>\&1} выделяются отдельно
    \item \textbf{Кавычки}: Текст внутри двойных кавычек обрабатывается как единое целое
    \item \textbf{Экранирование}: Символ \textbackslash{} экранирует следующий символ
\end{itemize}

\subsection{Функция \texttt{remove\_words}}
\begin{lstlisting}[language=C]
void remove_words(char **words, int *count, int start, int num) {
    if (start < 0 || start >= *count || num <= 0) return;
    
    // Освобождаем удаляемые токены
    for (int i = start; i < start + num && i < *count; i++) {
        free(words[i]);
    }
    
    // Сдвигаем оставшиеся токены
    for (int i = start; i < *count - num; i++) {
        words[i] = words[i + num];
    }
    
    *count -= num;
}
\end{lstlisting}

\textbf{Назначение}: Удаление группы токенов из массива слов.

\subsection{Функция \texttt{copy\_redirections}}
\begin{lstlisting}[language=C]
void copy_redirections(command_t *dest, const command_t *src) {
    if (src->input_file) dest->input_file = strdup(src->input_file);
    if (src->output_file) dest->output_file = strdup(src->output_file);
    if (src->error_file) dest->error_file = strdup(src->error_file);
    dest->append_output = src->append_output;
    dest->append_error = src->append_error;
    dest->merge_output = src->merge_output;
    dest->fonius = src->fonius;
}
\end{lstlisting}

\textbf{Назначение}: Копирование информации о перенаправлениях между командами.

\section{Парсинг последовательностей команд}

\subsection{Функция \texttt{parse\_input\_with\_separators}}
\begin{lstlisting}[language=C]
command_sequence_t *parse_input_with_separators(const char *input) {
    if (input == NULL || strlen(input) == 0) {
        return NULL;
    }

    // Сначала парсим всю строку как обычно
    command_t *full_cmd = parse_input(input);
    if (full_cmd == NULL) {
        return NULL;
    }

    command_sequence_t *seq = malloc(sizeof(command_sequence_t));
    if (seq == NULL) {
        perror("malloc");
        free_command(full_cmd);
        return NULL;
    }
    // ... продолжение парсинга последовательности
}
\end{lstlisting}

\textbf{Назначение}: Парсинг строки с разделителями команд на последовательность.

\textbf{Алгоритм работы}:
\begin{enumerate}
    \item Парсинг всей строки как единой команды
    \item Разделение на подкоманды по разделителям \texttt{;}, \texttt{\&\&}, \texttt{||}
    \item Создание отдельных структур \texttt{command\_t} для каждой подкоманды
    \item Сохранение информации о типах разделителей
    \item Копирование перенаправлений в подкоманды
\end{enumerate}

\subsection{Структура \texttt{command\_sequence\_t}}
\begin{lstlisting}[language=C]
typedef struct {
    command_t **commands;    // Массив команд
    int command_count;       // Количество команд в последовательности
    int *separators;         // Разделители между командами (0 - ;, 1 - &&, 2 - ||)
} command_sequence_t;
\end{lstlisting}

\section{Обработка перенаправлений и конвейеров}

\subsection{Функция \texttt{process\_redirections\_and\_pipes}}
\begin{lstlisting}[language=C]
void process_redirections_and_pipes(command_t *cmd, char **words, int *word_num) {
    int i = 0;
    
    while (i < *word_num) {
        // Пропускаем пустые слова и разделители команд
        if (words[i] == NULL || strlen(words[i]) == 0 || is_command_separator(words[i])) {
            i++;
            continue;
        }
        
        int tokens_to_remove = 0;
        char *filename = NULL;
        
        // Проверяем на перенаправления
        if (strcmp(words[i], ">") == 0) {
            // Обычное перенаправление вывода
            if (i + 1 >= *word_num) {
                fprintf(stderr, "Error: expected filename after '>'\n");
                i++;
                continue;
            }
            // ... обработка всех типов перенаправлений
        }
        // ... обработка других операторов
    }
}
\end{lstlisting}

\textbf{Назначение}: Обработка и извлечение операторов перенаправления из массива слов.

\textbf{Поддерживаемые операторы}:
\begin{itemize}
    \item \texttt{>} - перенаправление вывода (перезапись)
    \item \texttt{>>} - перенаправление вывода (дополнение)
    \item \texttt{<} - перенаправление ввода
    \item \texttt{2>} - перенаправление stderr (перезапись)
    \item \texttt{2>>} - перенаправление stderr (дополнение)
    \item \texttt{2>\&1} - объединение stderr с stdout
\end{itemize}

\section{Функции освобождения памяти}

\subsection{Функция \texttt{free\_command}}
\begin{lstlisting}[language=C]
void free_command(command_t *cmd) {
    if (cmd == NULL) return;

    // Освобождаем токены
    for (int i = 0; i < cmd->word_num; i++) {
        free(cmd->words[i]);
    }
    free(cmd->words);
    
    // Освобождаем имена файлов
    free(cmd->input_file);
    free(cmd->output_file);
    free(cmd->error_file);

    // Освобождаем конвейер (если есть)
    if (cmd->pipeline != NULL) {
        for (int i = 0; i < cmd->pipeline_count; i++) {
            for (int j = 0; cmd->pipeline[i][j] != NULL; j++) {
                free(cmd->pipeline[i][j]);
            }
            free(cmd->pipeline[i]);
        }
        free(cmd->pipeline);
    }
    
    free(cmd);
}
\end{lstlisting}

\textbf{Назначение}: Полное освобождение ресурсов структуры команды.

\subsection{Функция \texttt{free\_command\_sequence}}
\begin{lstlisting}[language=C]
void free_command_sequence(command_sequence_t *seq) {
    if (seq == NULL) return;
    
    for (int i = 0; i < seq->command_count; i++) {
        free_command(seq->commands[i]);
    }
    free(seq->commands);
    free(seq->separators);
    free(seq);
}
\end{lstlisting}

\textbf{Назначение}: Освобождение ресурсов последовательности команд.

\section{Функции отладки}

\subsection{Функция \texttt{print\_command}}
\begin{lstlisting}[language=C]
void print_command(const command_t *cmd) {
    if (cmd == NULL) {
        printf("Command: NULL\n");
        return;
    }
    
    printf("Command words: ");
    for (int i = 0; i < cmd->word_num; i++) {
        printf("[%s] ", cmd->words[i]);
    }
    printf("\n");
    
    printf("fonius: %s\n", cmd->fonius ? "yes" : "no");
    printf("Input file: %s\n", cmd->input_file ? cmd->input_file : "NULL");
    printf("Output file: %s\n", cmd->output_file ? cmd->output_file : "NULL");
    printf("Error file: %s\n", cmd->error_file ? cmd->error_file : "NULL");  
    printf("Append output: %s\n", cmd->append_output ? "yes" : "no");
    printf("Append error: %s\n", cmd->append_error ? "yes" : "no");          
    printf("Merge output: %s\n", cmd->merge_output ? "yes" : "no");          
    printf("Pipeline count: %d\n", cmd->pipeline_count);
}
\end{lstlisting}

\textbf{Назначение}: Вывод отладочной информации о команде.

\subsection{Функция \texttt{print\_command\_sequence}}
\begin{lstlisting}[language=C]
void print_command_sequence(const command_sequence_t *seq) {
    if (seq == NULL) {
        printf("Command sequence: NULL\n");
        return;
    }
    
    printf("Command sequence (%d commands):\n", seq->command_count);
    for (int i = 0; i < seq->command_count; i++) {
        printf("  Command %d: ", i + 1);
        for (int j = 0; j < seq->commands[i]->word_num; j++) {
            printf("[%s] ", seq->commands[i]->words[j]);
        }
        printf("\n");
        
        // Выводим информацию о перенаправлениях
        if (seq->commands[i]->input_file) 
            printf("    Input: %s\n", seq->commands[i]->input_file);
        if (seq->commands[i]->output_file) 
            printf("    Output: %s (%s)\n", seq->commands[i]->output_file, 
                   seq->commands[i]->append_output ? "append" : "trunc");
        // ... остальные поля
    }
}
\end{lstlisting}

\textbf{Назначение}: Вывод отладочной информации о последовательности команд.

\section{Примеры работы парсера}

\subsection{Пример 1: Простая команда}
\begin{verbatim}
Ввод: "ls -la"
Результат:
Command words: [ls] [-la] 
fonius: no
Input file: NULL
Output file: NULL
Error file: NULL
\end{verbatim}

\subsection{Пример 2: Команда с перенаправлениями}
\begin{verbatim}
Ввод: "ls -la > output.txt 2>&1"
Результат:
Command words: [ls] [-la] 
fonius: no
Input file: NULL
Output file: output.txt
Error file: NULL
Merge output: yes
\end{verbatim}

\subsection{Пример 3: Последовательность команд}
\begin{verbatim}
Ввод: "ls && pwd || echo error"
Результат:
Command sequence (3 commands):
  Command 1: [ls] 
  Separator: &&
  Command 2: [pwd] 
  Separator: ||
  Command 3: [echo] [error] 
\end{verbatim}

\subsection{Пример 4: Команда в фоновом режиме}
\begin{verbatim}
Ввод: "sleep 10 &"
Результат:
Command words: [sleep] [10] 
fonius: yes
\end{verbatim}

\section{Особенности реализации}

\subsection{Обработка специальных символов}
\begin{itemize}
    \item Символы \texttt{@\#\%!\& \$ \^{} ; : , ( ) \{ \} [ ]} считаются разделительными
    \item Двойные символы обрабатываются как единые токены
    \item Проверка корректности расположения операторов
\end{itemize}

\subsection{Управление памятью}
\begin{itemize}
    \item Все строки копируются с помощью \texttt{strdup()}
    \item Освобождение памяти при ошибках парсинга
    \item Рекурсивное освобождение вложенных структур
\end{itemize}

\subsection{Обработка ошибок}
\begin{itemize}
    \item Проверка границ массивов
    \item Валидация синтаксиса перенаправлений
    \item Корректная обработка неожиданного конца строки
\end{itemize}

\section{Взаимодействие с другими модулями}

\subsection{Зависимости}
\begin{itemize}
    \item \texttt{shell.h} - объявления структур и констант
    \item \texttt{executor.c} - использует результаты парсинга для выполнения команд
    \item \texttt{main.c} - передает входные данные для парсинга
\end{itemize}

\subsection{Поток данных}
\begin{enumerate}
    \item \texttt{main.c} → Входная строка от пользователя
    \item \texttt{parse\_input()} → Структура \texttt{command\_t}
    \item \texttt{executor.c} → Выполнение разобранной команды
\end{enumerate}

\section{Заключение}
Модуль \texttt{parcer.c} реализует сложный и надежный парсер командной строки, который корректно обрабатывает все основные конструкции shell'а. Парсер обеспечивает:

\begin{itemize}
    \item Полную поддержку стандартного синтаксиса командной строки
    \item Обработку специальных символов и операторов
    \item Поддержку перенаправлений ввода/вывода
    \item Парсинг последовательностей и конвейеров команд
    \item Надежное управление памятью и обработку ошибок
\end{itemize}

Модуль успешно интегрируется с другими компонентами системы и обеспечивает надежную основу для выполнения пользовательских команд.

\end{document}