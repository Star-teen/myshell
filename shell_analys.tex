\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{titlesec}
\usepackage{fancyhdr}

\geometry{left=2cm,right=2cm,top=2cm,bottom=2cm}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=single,
    framesep=5pt
}

\lstset{style=mystyle}

% Настройка заголовков разделов
\titleformat{\section}
{\Large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}
{\large\bfseries}{\thesubsection.}{1em}{}

% Настройка колонтитулов
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{Документация командного интерпретатора}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\title{Полная документация командного интерпретатора \\ Shell R v7.2}
\author{Разработчик: [Ваше имя]}
\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Данный документ представляет полную документацию по проекту командного интерпретатора, реализованного на языке C. Документация охватывает все основные модули системы: главный цикл выполнения, парсер командной строки, исполнитель команд, встроенные команды и главный заголовочный файл. Система обеспечивает полную функциональность UNIX-подобного shell'а с поддержкой конвейеров, перенаправлений, последовательностей команд и фонового выполнения.
\end{abstract}

\tableofcontents

\section{Введение}

\subsection{Обзор проекта}
Командный интерпретатор Shell R v7.2 представляет собой полнофункциональную реализацию shell'а, разработанную в соответствии с требованиями практикума. Система поддерживает все основные функции современных командных оболочек, включая:

\begin{itemize}
    \item Выполнение внешних и встроенных команд
    \item Поддержку конвейеров (pipes)
    \item Перенаправления ввода/вывода
    \item Последовательности команд с логическими операторами
    \item Фоновое выполнение процессов
    \item Управление переменными окружения
\end{itemize}

\subsection{Архитектура системы}
Система построена по модульному принципу и состоит из следующих основных компонентов:

\begin{itemize}
    \item \textbf{main.c} - главный цикл выполнения и взаимодействие с пользователем
    \item \textbf{parcer.c} - лексический анализ и парсинг командной строки
    \item \textbf{executor.c} - выполнение команд и управление процессами
    \item \textbf{cmdfrombash.c} - встроенные команды shell'а
    \item \textbf{shell.h} - главный заголовочный файл с объявлениями
\end{itemize}

\section{Модуль main.c - Главный цикл выполнения}

\subsection{Обзор модуля}
Файл \texttt{main.c} является главным модулем командного интерпретатора, который реализует основной цикл работы программы - чтение команд, их обработку и выполнение.

\subsection{Основные функции}

\subsubsection{Функция \texttt{check\_child}}
\begin{lstlisting}[language=C]
void check_child(int sig) {
    int status;
    pid_t pid;
    
    while ((pid = waitpid(-1, &status, WNOHANG)) > 0) {
        printf("[%d] Finished with status %d\n", pid, WEXITSTATUS(status));
    }
}
\end{lstlisting}

\textbf{Назначение}: Обработчик сигнала \texttt{SIGCHLD} для фоновых процессов.

\textbf{Функциональность}:
\begin{itemize}
    \item Использует \texttt{waitpid()} с флагом \texttt{WNOHANG} для неблокирующей проверки
    \item Выводит информацию о завершившихся фоновых процессах
    \item Автоматически вызывается при завершении любого дочернего процесса
\end{itemize}

\subsubsection{Функция \texttt{print\_dir}}
\begin{lstlisting}[language=C]
char* print_dir() {
    long size = pathconf(".", _PC_PATH_MAX);
    if (size == -1) {
        size = 4096;
    }

    char *cwd = malloc((size_t)size);
    if (cwd == NULL) {
        perror("malloc");
        exit(2);
    }

    cwd = getcwd(cwd, (size_t)size);
    if (cwd == NULL) {
        perror("getcwd");
        free(cwd);
        exit(2);
    }

    return cwd;
}
\end{lstlisting}

\textbf{Назначение}: Получение и форматирование текущей рабочей директории для приглашения.

\subsubsection{Функция \texttt{read\_line}}
\begin{lstlisting}[language=C]
char *read_line(void) {
    char *line = NULL;
    size_t linesize = 0;
    char* dir = print_dir();

    printf("%s> ", dir);
    fflush(stdout);
    free(dir);
    
    ssize_t num_chars_read = getline(&line, &linesize, stdin);
    
    if (num_chars_read <= 0) {
        free(line);
        return NULL;
    }
    
    if (line[num_chars_read - 1] == '\n') {
        line[num_chars_read - 1] = '\0';
    }
    
    return line;
}
\end{lstlisting}

\textbf{Назначение}: Чтение командной строки от пользователя.

\subsubsection{Функция \texttt{main}}
\begin{lstlisting}[language=C]
int main(void) {
    char *input;
    
    signal(SIGCHLD, check_child);
    
    printf("Shell R v7.2\n");
    printf("Type 'exit' to quit. Or use Ctrl + D\n");
    
    while ((input = read_line()) != NULL) {
        if (strlen(input) == 0) {
            free(input);
            continue;
        }
    
        // Парсим как единую команду с перенаправлениями
        command_t *cmd = parse_input(input);
        
        if (cmd != NULL) {
            // Выполняем команду
            execute_command(cmd);
            free_command(cmd);
        }        
    
        free(input);
    }
    
    printf("\nGoodbye!\n");
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Главная функция программы, реализующая основной цикл работы.

\subsection{Ключевые особенности}
\begin{itemize}
    \item \textbf{Обработка сигналов}: Корректное отслеживание фоновых процессов
    \item \textbf{Динамическое управление памятью}: Правильное выделение и освобождение ресурсов
    \item \textbf{Интерактивный интерфейс}: Информативное приглашение с текущей директорией
    \item \textbf{Обработка ошибок}: Проверка возвращаемых значений системных вызовов
\end{itemize}

\section{Модуль parcer.c - Парсер командной строки}

\subsection{Обзор модуля}
Файл \texttt{parcer.c} является модулем парсинга командной строки, который преобразует текстовый ввод пользователя в структурированные команды с учетом специальных символов, кавычек, экранирования и перенаправлений.

\subsection{Вспомогательные функции}

\subsubsection{Функция \texttt{is\_special\_char}}
\begin{lstlisting}[language=C]
int is_special_char(char c) {
    const char *special_chars = "@#%!&$^;:,(){}[]";
    return (strchr(special_chars, c) != NULL);
}
\end{lstlisting}

\textbf{Назначение}: Проверка, является ли символ специальным.

\subsubsection{Функция \texttt{is\_redirection\_char}}
\begin{lstlisting}[language=C]
int is_redirection_char(char *str) {
    return (strcmp(str, ">") == 0 || strcmp(str, ">>") == 0 || 
            strcmp(str, "<") == 0 || strcmp(str, "2>") == 0 || 
            strcmp(str, "2>>") == 0 || strcmp(str, "2>&1") == 0);
}
\end{lstlisting}

\textbf{Назначение}: Проверка, является ли строка оператором перенаправления.

\subsubsection{Функция \texttt{is\_command\_separator}}
\begin{lstlisting}[language=C]
int is_command_separator(const char *str) {
    return (strcmp(str, ";") == 0 || strcmp(str, "&&") == 0 || strcmp(str, "||") == 0);
}
\end{lstlisting}

\textbf{Назначение}: Проверка, является ли строка разделителем команд.

\subsection{Основные функции парсинга}

\subsubsection{Функция \texttt{parse\_input}}
\begin{lstlisting}[language=C]
command_t *parse_input(const char *input) {
    if (input == NULL || strlen(input) == 0) {
        return NULL;
    }

    command_t *cmd = malloc(sizeof(command_t));
    // ... инициализация и парсинг
    return cmd;
}
\end{lstlisting}

\textbf{Назначение}: Основная функция парсинга входной строки в структуру команды.

\textbf{Алгоритм работы}:
\begin{enumerate}
    \item Проверка входных данных и выделение памяти
    \item Инициализация структуры \texttt{command\_t}
    \item Посимвольный анализ с учетом экранирования и кавычек
    \item Обработка фонового режима
    \item Обработка перенаправлений и конвейеров
\end{enumerate}

\subsubsection{Функция \texttt{parse\_input\_with\_separators}}
\begin{lstlisting}[language=C]
command_sequence_t *parse_input_with_separators(const char *input) {
    // Сначала парсим всю строку как обычно
    command_t *full_cmd = parse_input(input);
    // ... разделение на последовательность команд
}
\end{lstlisting}

\textbf{Назначение}: Парсинг строки с разделителями команд на последовательность.

\subsection{Обработка перенаправлений}

\subsubsection{Функция \texttt{process\_redirections\_and\_pipes}}
\begin{lstlisting}[language=C]
void process_redirections_and_pipes(command_t *cmd, char **words, int *word_num) {
    int i = 0;
    while (i < *word_num) {
        // Обработка всех типов перенаправлений
        if (strcmp(words[i], ">") == 0) {
            // Обработка перенаправления вывода
        }
        // ... другие операторы
    }
}
\end{lstlisting}

\textbf{Назначение}: Обработка и извлечение операторов перенаправления из массива слов.

\textbf{Поддерживаемые операторы}:
\begin{itemize}
    \item \texttt{>} - перенаправление вывода (перезапись)
    \item \texttt{>>} - перенаправление вывода (дополнение)
    \item \texttt{<} - перенаправление ввода
    \item \texttt{2>} - перенаправление stderr (перезапись)
    \item \texttt{2>>} - перенаправление stderr (дополнение)
    \item \texttt{2>\&1} - объединение stderr с stdout
\end{itemize}

\subsection{Функции освобождения памяти}

\subsubsection{Функция \texttt{free\_command}}
\begin{lstlisting}[language=C]
void free_command(command_t *cmd) {
    if (cmd == NULL) return;
    // Освобождение токенов, файловых имен и конвейера
}
\end{lstlisting}

\textbf{Назначение}: Полное освобождение ресурсов структуры команды.

\section{Модуль executor.c - Исполнитель команд}

\subsection{Обзор модуля}
Файл \texttt{executor.c} является модулем выполнения команд, который реализует механизмы выполнения внешних команд, встроенных команд, конвейеров, последовательностей команд с учетом логических операторов и перенаправлений ввода/вывода.

\subsection{Функции управления перенаправлениями}

\subsubsection{Функция \texttt{apply\_redirections}}
\begin{lstlisting}[language=C]
int apply_redirections(command_t *cmd) {
    // Перенаправление ввода (stdin)
    if (cmd->input_file != NULL) {
        int fd = open(cmd->input_file, O_RDONLY);
        // ... применение перенаправления
    }
    // ... другие типы перенаправлений
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Применение всех перенаправлений ввода/вывода для команды.

\subsection{Функции поиска и выполнения команд}

\subsubsection{Функция \texttt{get\_full\_path}}
\begin{lstlisting}[language=C]
char *get_full_path(const char *command) {
    if (command == NULL || command[0] == '\0') {
        return NULL;
    }
    // Поиск в PATH или проверка абсолютных путей
}
\end{lstlisting}

\textbf{Назначение}: Поиск полного пути к исполняемому файлу команды.

\subsubsection{Функция \texttt{execute\_external}}
\begin{lstlisting}[language=C]
int execute_external(command_t *cmd) {
    char *full_path = get_full_path(cmd->words[0]);
    pid_t pid = fork();
    
    if (pid == 0) {
        // Дочерний процесс - применение перенаправлений и execv
    } else {
        // Родительский процесс - ожидание или фоновая работа
    }
}
\end{lstlisting}

\textbf{Назначение}: Выполнение внешней команды.

\subsection{Функции работы с конвейерами}

\subsubsection{Функция \texttt{execute\_pipeline}}
\begin{lstlisting}[language=C]
int execute_pipeline(command_t *cmd) {
    int cmd_count;
    command_t **commands = split_pipeline(cmd, &cmd_count);
    // Создание pipe'ов и процессов для каждой команды
}
\end{lstlisting}

\textbf{Назначение}: Выполнение конвейера команд.

\textbf{Алгоритм работы}:
\begin{enumerate}
    \item Разделение конвейера на отдельные команды
    \item Создание необходимого количества pipe'ов
    \item Создание процессов для каждой команды
    \item Настройка перенаправлений между процессами
    \item Ожидание завершения всех процессов
\end{enumerate}

\subsection{Функции работы с последовательностями команд}

\subsubsection{Функция \texttt{execute\_command\_sequence}}
\begin{lstlisting}[language=C]
int execute_command_sequence(command_sequence_t *seq) {
    int last_status = 0;
    int should_execute_next = 1;
    
    for (int i = 0; i < seq->command_count; i++) {
        // Выполнение с учетом логических операторов
    }
    return last_status;
}
\end{lstlisting}

\textbf{Назначение}: Выполнение последовательности команд с учетом логических операторов.

\textbf{Логика выполнения}:
\begin{itemize}
    \item \textbf{;} - всегда выполнять следующую команду
    \item \textbf{\&\&} - выполнять только при успехе (status = 0)
    \item \textbf{||} - выполнять только при ошибке (status ≠ 0)
\end{itemize}

\subsection{Главная функция выполнения}

\subsubsection{Функция \texttt{execute\_command}}
\begin{lstlisting}[language=C]
int execute_command(command_t *cmd) {
    // Проверка на последовательности, конвейеры, встроенные команды
    // и выполнение внешних команд
}
\end{lstlisting}

\textbf{Назначение}: Главная функция выполнения команды, определяющая тип команды и направляющая ее на соответствующий обработчик.

\section{Модуль cmdfrombash.c - Встроенные команды}

\subsection{Обзор модуля}
Файл \texttt{cmdfrombash.c} содержит реализацию встроенных команд shell'а, которые выполняются непосредственно в процессе интерпретатора без создания дочерних процессов.

\subsection{Функции встроенных команд}

\subsubsection{Функция \texttt{from\_bash\_cd}}
\begin{lstlisting}[language=C]
int from_bash_cd(char **args) {
    if (args[1] == NULL) return 1;
    if (chdir(args[1]) != 0) {
        perror("cd");
        return 1;
    }
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Смена текущей рабочей директории.

\subsubsection{Функция \texttt{from\_bash\_exit}}
\begin{lstlisting}[language=C]
int from_bash_exit(char **args) {
    int exit_code = 0;
    if (args[1] != NULL) exit_code = atoi(args[1]);
    exit(exit_code);
}
\end{lstlisting}

\textbf{Назначение}: Завершение работы shell'а.

\subsubsection{Функция \texttt{from\_path}}
\begin{lstlisting}[language=C]
int from_path(char **args) {
    char *path = getenv("PATH");
    if (path == NULL) printf("PATH is not set\n");
    else printf("PATH=%s\n", path);
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Вывод текущего значения переменной окружения PATH.

\subsubsection{Функция \texttt{set\_path}}
\begin{lstlisting}[language=C]
int set_path(char **args) {
    if (args[1] == NULL) return 1;
    if (setenv("PATH", args[1], 1) != 0) {
        perror("setpath");
        return 1;
    }
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Установка нового значения переменной PATH.

\subsubsection{Функция \texttt{add\_to\_path}}
\begin{lstlisting}[language=C]
int add_to_path(char **args) {
    // Добавление директории в начало PATH
}
\end{lstlisting}

\textbf{Назначение}: Добавление директории в начало переменной PATH.

\subsubsection{Функция \texttt{reset\_path}}
\begin{lstlisting}[language=C]
int reset_path(char **args) {
    const char *default_path = "...";
    if (setenv("PATH", default_path, 1) != 0) {
        perror("resetpath");
        return 1;
    }
    return 0;
}
\end{lstlisting}

\textbf{Назначение}: Сброс переменной PATH к значению по умолчанию.

\subsection{Главная функция диспетчеризации}

\subsubsection{Функция \texttt{execute\_bash\_cmd}}
\begin{lstlisting}[language=C]
int execute_bash_cmd(char **args) {
    if (strcmp(args[0], "cd") == 0) return from_bash_cd(args);
    else if (strcmp(args[0], "exit") == 0) return from_bash_exit(args);
    // ... другие команды
    return -1; // Не встроенная команда
}
\end{lstlisting}

\textbf{Назначение}: Определение и вызов соответствующей встроенной команды.

\section{Модуль shell.h - Главный заголовочный файл}

\subsection{Обзор файла}
Файл \texttt{shell.h} является главным заголовочным файлом проекта, который содержит все объявления структур данных, констант и функций, используемых в командном интерпретаторе.

\subsection{Константы и макросы}
\begin{lstlisting}[language=C]
#define MAX_INPUT_LENGTH 4096
#define MAX_WORDS 100
#define MAX_PATH_LENGTH 1024
\end{lstlisting}

\textbf{Назначение}: Определение констант для ограничения размеров данных в системе.

\subsection{Структуры данных}

\subsubsection{Структура \texttt{command\_t}}
\begin{lstlisting}[language=C]
typedef struct {
    char **words;
    int word_num;
    int fonius;
    char *input_file;
    char *output_file;
    char *error_file;
    int append_output;
    int append_error;
    int merge_output;
    char ***pipeline;
    int pipeline_count;
} command_t;
\end{lstlisting}

\textbf{Назначение}: Представление разобранной команды со всеми атрибутами и перенаправлениями.

\subsubsection{Структура \texttt{command\_sequence\_t}}
\begin{lstlisting}[language=C]
typedef struct {
    command_t **commands;
    int command_count;
    int *separators;
} command_sequence_t;
\end{lstlisting}

\textbf{Назначение}: Представление последовательности команд, разделенных операторами.

\subsection{Прототипы функций}

\subsubsection{Функции парсера}
\begin{lstlisting}[language=C]
command_t *parse_input(const char *input);
command_sequence_t *parse_input_with_separators(const char *input);
void free_command(command_t *cmd);
void free_command_sequence(command_sequence_t *seq);
\end{lstlisting}

\subsubsection{Функции исполнителя}
\begin{lstlisting}[language=C]
int execute_command(command_t *cmd);
int execute_command_sequence(command_sequence_t *seq);
int execute_bash_cmd(char **args);
int execute_pipeline(command_t *cmd);
\end{lstlisting}

\subsubsection{Встроенные команды}
\begin{lstlisting}[language=C]
int from_bash_cd(char **args);
int from_bash_exit(char **args);
int from_path(char **args);
int set_path(char **args);
int add_to_path(char **args);
int reset_path(char **args);
\end{lstlisting}

\subsubsection{Функции отладки и утилиты}
\begin{lstlisting}[language=C]
void print_command(const command_t *cmd);
void print_command_sequence(const command_sequence_t *seq);
char *read_line(void);
char *get_full_path(const char *command);
\end{lstlisting}

\section{Взаимодействие модулей}

\subsection{Архитектурная схема}
Система построена по принципу конвейера обработки данных:

\begin{enumerate}
    \item \textbf{Ввод}: \texttt{main.c} → чтение строки от пользователя
    \item \textbf{Парсинг}: \texttt{parcer.c} → преобразование в структурированную команду
    \item \textbf{Диспетчеризация}: \texttt{executor.c} → определение типа команды
    \item \textbf{Выполнение}: соответствующий модуль → выполнение команды
    \item \textbf{Обратная связь}: вывод результатов и обновление состояния
\end{enumerate}

\subsection{Потоки данных}
\begin{itemize}
    \item \texttt{main.c} ↔ \texttt{parcer.c}: передача строки для парсинга
    \item \texttt{main.c} ↔ \texttt{executor.c}: передача команд для выполнения
    \item \texttt{executor.c} ↔ \texttt{cmdfrombash.c}: вызов встроенных команд
    \item Все модули ↔ \texttt{shell.h}: использование общих структур и функций
\end{itemize}

\subsection{Управление памятью}
\begin{itemize}
    \item \textbf{Парсер} создает структуры команд и выделяет память
    \item \textbf{Исполнитель} использует созданные структуры без копирования
    \item \textbf{main.c} отвечает за освобождение ресурсов после выполнения
    \item Все модули следуют единой стратегии управления памятью
\end{itemize}

\section{Примеры использования системы}

\subsection{Пример 1: Простая команда с перенаправлением}
\begin{verbatim}
$ ls -la > output.txt
\end{verbatim}

\textbf{Обработка}:
\begin{enumerate}
    \item Парсинг: создание \texttt{command\_t} с \texttt{words = ["ls", "-la"]}, \texttt{output\_file = "output.txt"}
    \item Выполнение: \texttt{fork()} + \texttt{execv()} с применением перенаправления
\end{enumerate}

\subsection{Пример 2: Конвейер}
\begin{verbatim}
$ ps aux | grep python | wc -l
\end{verbatim}

\textbf{Обработка}:
\begin{enumerate}
    \item Парсинг: разделение на 3 команды в конвейере
    \item Выполнение: создание 2 pipe'ов и 3 процессов с соединением STDIN/STDOUT
\end{enumerate}

\subsection{Пример 3: Последовательность с логическими операторами}
\begin{verbatim}
$ make && make test || echo "Build failed"
\end{verbatim}

\textbf{Обработка}:
\begin{enumerate}
    \item Парсинг: создание последовательности из 3 команд с разделителями \&\& и ||
    \item Выполнение: условное выполнение на основе статусов предыдущих команд
\end{enumerate}

\section{Заключение}

\subsection{Достигнутая функциональность}
Разработанный командный интерпретатор обеспечивает полный набор функций, требуемых для получения высшей оценки:

\begin{itemize}
    \item ✅ Выполнение внешних и встроенных команд
    \item ✅ Поддержка конвейеров произвольной длины
    \item ✅ Все виды перенаправлений ввода/вывода
    \item ✅ Последовательности команд с операторами ;, \&\&, ||
    \item ✅ Фоновое выполнение процессов
    \item ✅ Управление переменными окружения
    \item ✅ Обработка кавычек и экранирования
\end{itemize}

\subsection{Архитектурные преимущества}
\begin{itemize}
    \item \textbf{Модульность}: Четкое разделение ответственности между компонентами
    \item \textbf{Расширяемость}: Легкое добавление новых встроенных команд и функций
    \item \textbf{Надежность}: Корректная обработка ошибок и управление памятью
    \item \textbf{Эффективность}: Минимальное копирование данных между модулями
\end{itemize}

\subsection{Перспективы развития}
Система может быть расширена следующими функциями:
\begin{itemize}
    \item Поддержка скриптовых файлов
    \item История команд
    \item Автодополнение команд
    \item Подстановка переменных окружения
    \item Job control (управление заданиями)
\end{itemize}

Разработанный командный интерпретатор представляет собой законченную, надежную и расширяемую систему, соответствующую всем современным требованиям к UNIX-подобным оболочкам.

\end{document}